
======= cache/solpp-generated-contracts/FutureCash.sol:FutureCash =======
Developer Documentation
{
  "methods":
  {
    "addLiquidity(uint32,uint128,uint128)":
    {
      "params":
      {
        "maturity": "the period to add liquidity to",
        "maxDai": "the maximum amount of dai to add to the pool",
        "minFutureCash": "the amount of future cash to add to the pool"
      }
    },
    "depositDai(uint128)":
    {
      "params":
      {
        "amount": "the amount of dai to deposit into the contract"
      }
    },
    "freeCollateral(address)":
    {
      "params":
      {
        "account": "the account to do the check for"
      }
    },
    "getDaiToFutureCashInput(uint32,uint128)":
    {
      "params":
      {
        "daiAmount": "the amount of dai to put into the market",
        "maturity": "the maturity of the future cash"
      },
      "returns":
      {
        "_0": "the amount of future cash this would purchase"
      }
    },
    "getDaiToFutureCashOutput(uint32,uint128)":
    {
      "params":
      {
        "futureCashAmount": "the amount of future cash that you want to purchase",
        "maturity": "the maturity of the future cash"
      },
      "returns":
      {
        "_0": "the amount of dai that this would cost"
      }
    },
    "getFutureCashToDaiInput(uint32,uint128)":
    {
      "params":
      {
        "futureCashAmount": "the amount of future cash to input",
        "maturity": "the maturity of the future cash"
      },
      "returns":
      {
        "_0": "the amount of current dai this would purchase"
      }
    },
    "getFutureCashToDaiOutput(uint32,uint128)":
    {
      "params":
      {
        "daiAmount": "the amount of dai that you want to purchase",
        "maturity": "the maturity of the future cash"
      },
      "returns":
      {
        "_0": "the amount of future dai that must be sold to purchase `daiAmount`"
      }
    },
    "getRate(uint32)":
    {
      "params":
      {
        "maturity": "the maturity to get the rate for"
      },
      "returns":
      {
        "_0": "a tuple where the first value is the simple discount rate and the second value is a boolean indicating whether or not the maturity has passed"
      }
    },
    "getTokenValue(uint32,uint128)":
    {
      "params":
      {
        "amount": "the amount of liquidity tokens to value",
        "maturity": "the period of the market to be referenced"
      },
      "returns":
      {
        "_0": "a tuple, the current dai value is the first value, the present value of the future cash is the second value"
      }
    },
    "isOwner()":
    {
      "details": "Returns true if the caller is the current owner."
    },
    "liquidate(address)":
    {
      "params":
      {
        "account": "the account to liquidate"
      }
    },
    "owner()":
    {
      "details": "Returns the address of the current owner."
    },
    "removeLiquidity(uint32,uint128,uint256)":
    {
      "params":
      {
        "amount": "the amount of liquidity tokens to burn",
        "index": "the index in the portfolio where the liquidity tokens are located",
        "maturity": "the period to remove liquidity from"
      }
    },
    "renounceOwnership()":
    {
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner.     * NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "settle(address)":
    {
      "params":
      {
        "account": "the address of the account to settle"
      }
    },
    "settleBatch(address[])":
    {
      "params":
      {
        "accounts": "an array of addresses to settle"
      }
    },
    "settleCash(address,int256)":
    {
      "params":
      {
        "counterparty": "the counterparty to settle a cash balance against",
        "value": "the amount of cash (positive or negative) to settle"
      }
    },
    "takeDai(uint32,uint128)":
    {
      "params":
      {
        "futureCashAmount": "the amount of future cash to deposit, will convert this amount to current cash at the prevailing exchange rate",
        "maturity": "the maturity block of the future cash being exchange for current cash"
      }
    },
    "takeFutureCash(uint32,uint128)":
    {
      "params":
      {
        "daiAmount": "the amount of collateral to deposit",
        "maturity": "the period to receive future cash in"
      }
    },
    "transferFutureCash(address,uint256,uint128)":
    {
      "params":
      {
        "amount": "the amount of notional to transfer",
        "index": "the position in an account's portfolio to transfer",
        "to": "the destination account to send the token to"
      }
    },
    "transferOwnership(address)":
    {
      "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
    },
    "withdrawDai(uint128)":
    {
      "params":
      {
        "amount": "the amount of dai to withdraw"
      }
    },
    "withdrawEth(uint128)":
    {
      "details": "We do not use `msg.sender.transfer` or `msg.sender.send` as recommended by Consensys: https://diligence.consensys.net/blog/2019/09/stop-using-soliditys-transfer-now/",
      "params":
      {
        "amount": "the amount of eth to withdraw from the contract"
      }
    }
  }
}
User Documentation
{
  "methods":
  {
    "addLiquidity(uint32,uint128,uint128)":
    {
      "notice": "Adds some amount of future cash to the liquidity pool up to the corresponding amount defined by `maxDai`. Mints liquidity tokens back to the sender."
    },
    "depositDai(uint128)":
    {
      "notice": "Deposit DAI into the contract for lending. The Dai contract must give proper allowances to this contract in order to do the transfer from the sender."
    },
    "depositEth()":
    {
      "notice": "Deposit ETH to use as collateral for loans. All future cash is denominated in Dai so this is only useful as collateral for borrowing. Lenders will have to deposit dai in order to purchase future cash. The amount of eth deposited should be set in `msg.value`."
    },
    "freeCollateral(address)":
    {
      "notice": "Checks that an account has sufficient collateral to cover its obligations. This works by calculating the difference between two amounts, the net present value of the portfolio and the value of the cash and collateral on hand, denominated in dai."
    },
    "getAccountTrades(address)":
    {
      "notice": "Returns the trade array "
    },
    "getActiveMaturities()":
    {
      "notice": "Gets the maturities for all the active markets."
    },
    "getDaiToFutureCashInput(uint32,uint128)":
    {
      "notice": "Given the amount of dai to put into a market returns how much future cash this would purchase."
    },
    "getDaiToFutureCashOutput(uint32,uint128)":
    {
      "notice": "Given the amount of future cash you want to purchase, returns how much current dai this would cost."
    },
    "getFutureCashToDaiInput(uint32,uint128)":
    {
      "notice": "Given the amount of future cash put into a market, how much current dai this would purchase."
    },
    "getFutureCashToDaiOutput(uint32,uint128)":
    {
      "notice": "Given the amount of dai that you want to purchase, returns the amount of future cash required to put into the market."
    },
    "getMarketRates()":
    {
      "notice": "Gets the rates for all the active markets."
    },
    "getRate(uint32)":
    {
      "notice": "Returns the current discount rate for the market. This will return 0 when presented with a negative interest rate."
    },
    "getTokenValue(uint32,uint128)":
    {
      "notice": "Returns the present value of an amount of liquidity tokens."
    },
    "liquidate(address)":
    {
      "notice": "Liquidates an account when it becomes undercollateralized. It does this by first selling off any ETH and positive NPV trades in the portfolio in order to raise the shortfall returned by the free collateral call. Then it pays a liquidity reward to the liquidator. Finally, it uses the remaining dai to purchase offsetting positions to any outstanding obligations (i.e. CASH_PAYER tokens) to de-risk the portfolio."
    },
    "removeLiquidity(uint32,uint128,uint256)":
    {
      "notice": "Removes liquidity from the future cash market. The sender's liquidity tokens are burned and they are credited back with future cash and dai at the prevailing exchange rate. This function only works when removing liquidity from an active market. For markets that are matured, the sender must settle their liquidity token because it involves depositing current cash and settling future cash balances."
    },
    "settle(address)":
    {
      "notice": "Settles all matured cash trades and liquidity tokens in a user's portfolio. This method is unauthenticated, anyone may settle the trades in any account. This is required for accounts that have negative cash and counterparties need to settle against them."
    },
    "settleBatch(address[])":
    {
      "notice": "The batch version of the `settle` call."
    },
    "settleCash(address,int256)":
    {
      "notice": "Settles cash balances that parties hold. This is an important concept in Swapnet because we cannot settle trades directly to collateral. Parties must find counterparty with enough of a negative current cash balance to settle against before they can withdraw their collateral."
    },
    "takeDai(uint32,uint128)":
    {
      "notice": "Receive dai in exchange for a future cash obligation which must be collateralized by ETH or other future cash receiver obligations. Equivalent to borrowing dai at a fixed rate."
    },
    "takeFutureCash(uint32,uint128)":
    {
      "notice": "Deposit dai in return for the right to receive cash at the specified maturity. Equivalent to lending your dai at a fixed rate."
    },
    "transferFutureCash(address,uint256,uint128)":
    {
      "notice": "Transfers the future cash from the sender to the specified destination address. This can only be done with CASH_RECEIVER or LIQUIDITY_TOKEN objects. CASH_PAYER represents and obligation and therefore it cannot be transferred. The sender must pass a free collateral check, the receiver will be NPV positive after the transfer so they do not require a free collateral check."
    },
    "withdrawDai(uint128)":
    {
      "notice": "Withdraw Dai from the contract back to the sender. Can only be done if the sender passes a free collateral check."
    },
    "withdrawEth(uint128)":
    {
      "notice": "Withdraw ETH from the contract. This can only be done after a successful free collateral check."
    }
  },
  "notice": "A demo contract of the future cash market "
}

======= cache/solpp-generated-contracts/SafeInt256.sol:SafeInt256 =======
Developer Documentation
{
  "methods": {}
}
User Documentation
{
  "methods": {}
}

======= cache/solpp-generated-contracts/SafeUInt128.sol:SafeUInt128 =======
Developer Documentation
{
  "methods": {}
}
User Documentation
{
  "methods": {}
}

======= cache/solpp-generated-contracts/lib/Context.sol:Context =======
Developer Documentation
{
  "methods": {}
}
User Documentation
{
  "methods": {}
}

======= cache/solpp-generated-contracts/lib/IERC20.sol:IERC20 =======
Developer Documentation
{
  "details": "Interface of the ERC20 standard as defined in the EIP. Does not include the optional functions; to access them see {ERC20Detailed}.",
  "methods":
  {
    "allowance(address,address)":
    {
      "details": "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default.     * This value changes when {approve} or {transferFrom} are called."
    },
    "approve(address,uint256)":
    {
      "details": "Sets `amount` as the allowance of `spender` over the caller's tokens.     * Returns a boolean value indicating whether the operation succeeded.     * IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729     * Emits an {Approval} event."
    },
    "balanceOf(address)":
    {
      "details": "Returns the amount of tokens owned by `account`."
    },
    "totalSupply()":
    {
      "details": "Returns the amount of tokens in existence."
    },
    "transfer(address,uint256)":
    {
      "details": "Moves `amount` tokens from the caller's account to `recipient`.     * Returns a boolean value indicating whether the operation succeeded.     * Emits a {Transfer} event."
    },
    "transferFrom(address,address,uint256)":
    {
      "details": "Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance.     * Returns a boolean value indicating whether the operation succeeded.     * Emits a {Transfer} event."
    }
  }
}
User Documentation
{
  "methods": {}
}

======= cache/solpp-generated-contracts/lib/Ownable.sol:Ownable =======
Developer Documentation
{
  "details": "Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. * This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.",
  "methods":
  {
    "constructor":
    {
      "details": "Initializes the contract setting the deployer as the initial owner."
    },
    "isOwner()":
    {
      "details": "Returns true if the caller is the current owner."
    },
    "owner()":
    {
      "details": "Returns the address of the current owner."
    },
    "renounceOwnership()":
    {
      "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner.     * NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
    },
    "transferOwnership(address)":
    {
      "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
    }
  }
}
User Documentation
{
  "methods": {}
}

======= cache/solpp-generated-contracts/lib/SafeMath.sol:SafeMath =======
Developer Documentation
{
  "details": "Wrappers over Solidity's arithmetic operations with added overflow checks. * Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. `SafeMath` restores this intuition by reverting the transaction when an operation overflows. * Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.",
  "methods": {}
}
User Documentation
{
  "methods": {}
}

======= cache/solpp-generated-contracts/lib/UniswapExchangeInterface.sol:UniswapExchangeInterface =======
Developer Documentation
{
  "methods": {}
}
User Documentation
{
  "methods": {}
}
